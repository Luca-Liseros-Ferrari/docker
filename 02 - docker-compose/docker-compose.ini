; ====================================================
; GUIDA OPERATIVA DOCKER COMPOSE (Tomcat + MySQL)
; ====================================================

[STEP_1_PERSISTENCE_XML]
; RICORDA:
; - Il nome del DB, la porta e le credenziali in persistence.xml 
;   DEVONO coincidere con quelli che userai nel docker-compose.yml
; - Se il DB si chiama "mydb" nel .yml, anche persistence.xml deve puntare a "mydb".
; - Stesso discorso per host (db), porta (3306) e user/password.
;
; Suggerimento: 
; <property name="jakarta.persistence.jdbc.url" value="jdbc:mysql://db:3306/mydb" />
; <property name="jakarta.persistence.jdbc.user" value="root" />
; <property name="jakarta.persistence.jdbc.password" value="password" />

[STEP_2_CREAZIONE_FILE_SQL]
; - Avvia l'app una prima volta con JPA
; - Copia dallo startup log del container DB i comandi SQL generati (CREATE TABLE, INSERT, ecc.)
;   docker logs nome-container-db
; - Crea un file init.sql con questi comandi
; - Salvalo in una cartella locale ./db
;   (questa cartella verrà montata in /docker-entrypoint-initdb.d del container MySQL)
; - il nome del database dovrà essere uguale a quello specificato nel .yml

[STEP_3_BUILD_WAR]
; - Compila il progetto con Maven
mvn clean package

; - Troverai il file .war
; - Crea una cartella ./tomcat/webapps all'interno del folder del compose
; - Copia il .war in questa cartella
; - Rinominare il file in ROOT.war serve a far partire l'applicazione direttamente
;   sulla root di Tomcat. Senza questo, l'app sarebbe accessibile all'URL:
;      http://localhost:8080/NOME_WAR
;   Con ROOT.war invece sarà accessibile direttamente a:
;      http://localhost:8080/

[STEP_4_ENV_FILE]
; - Crea un file .env nella root del progetto per le variabili sensibili
;   Esempio:
; EMAIL_USER=you@example.com
; EMAIL_PASSWORD=yourpassword
; MYSQL_ROOT_PASSWORD=password
; MYSQL_DATABASE=mydb
; MYSQL_PASSWORD=password

[STEP_5_DOCKER_COMPOSE_FILE]
; - Crea un file docker-compose.yml con la seguente struttura:

version: '3.8'

networks:
  mynetwork:
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: "172.22.0.0/19"
          gateway: "172.22.0.3"

services:
  web:
    image: tomcat:9-jdk17-openjdk
    container_name: web
    ports:
      - "8080:8080"
    volumes:
      - ./tomcat/webapps/ROOT.war:/usr/local/tomcat/webapps/ROOT.war
    environment:
      - EMAIL_USER=${EMAIL_USER}
      - EMAIL_PASSWORD=${EMAIL_PASSWORD}
    networks:
      - mynetwork

  db:
    image: mysql:8.0
    container_name: db
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE} ; - il nome del database dovrà essere uguale a quello specificato nel .yml
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    ports:
      - "3308:3306"
    volumes:
      - ./db:/docker-entrypoint-initdb.d
    networks:
      - mynetwork

[STEP_6_NETWORK_NOTA_IMPORTANTE]
; - Tutti i container devono stare nello stesso network per comunicare tra loro.
; - Nel compose sopra creiamo un network custom "mynetwork".
; - Nel persistence.xml, l'host del DB sarà il nome del servizio Docker (db), non "localhost".
; - Questo perché Docker risolve automaticamente i container tramite DNS interno al network.
; - Esempio URL JDBC:
;   jdbc:mysql://db:3306/mydb

[STEP_7_COMANDI_DOCKER_COMPOSE]
; Build e avvio dei servizi
docker-compose up --build -d

; Vedere i container attivi
docker-compose ps

[STEP_8_DEBUG]
; --- Logs ---
; Vedi log del DB:
docker logs db

; Vedi log di Tomcat:
docker logs web

; --- Accesso al DB ---
; Entra nel container DB:
docker exec -it db mysql -u root -p
; Dentro MySQL:
; SHOW DATABASES;
; USE NOME_DB;
; SHOW TABLES;

; --- Test rete tra i container ---
; Lista i network attivi:
docker network ls

; Vedi i dettagli del network mynetwork:
docker network inspect mynetwork

; Test ping dal container web verso db:
docker exec -it web ping db

; (Opzionale) apri una shell dentro web:
docker exec -it web bash
; Dentro prova a risolvere il nome host db:
ping db
; oppure:
apt-get update && apt-get install -y netcat
nc -zv db 3306   ; verifica se la porta MySQL è raggiungibile

; Fermare e rimuovere i container e il network
docker-compose down

[STEP_9_TROUBLESHOOTING]
; --- Problemi comuni connessione Tomcat → MySQL ---
; Se dopo docker-compose up il container web non riesce a collegarsi al DB:
; 1) Controlla che l'host nel persistence.xml punti al nome del container DB:
;      jdbc:mysql://db:3306/NOME_DB
;    - NON usare localhost (indica il container web stesso)
;    - La porta deve essere quella interna del container MySQL (3306)
;
; 2) Verifica che il nome del database e le credenziali siano identici a quelli definiti nel docker-compose.yml
;      MYSQL_DATABASE, MYSQL_ROOT_PASSWORD, MYSQL_PASSWORD
;
; 3) Assicurati che entrambi i container siano sullo stesso network:
      docker network inspect mynetwork
;    - Se sono dichiarati nel docker-compose.yml sullo stesso network, Compose li collega automaticamente.
;    - Non è necessario usare "docker network connect" manualmente.
;
; 4) Controlla i log del container web per errori JDBC:
;      docker logs web
;    - Eventuali messaggi tipo "Connection refused" indicano host/porta errati.
;
; 5) Controlla i log del container DB:
    docker logs db
;    - Assicurati che MySQL sia pronto a ricevere connessioni.

; 6) Soluzione manuale (se i container non risultano collegati):
      docker network inspect mynetwork
;   - se ci sarà un oggetto vuoto {}
      docker network connect mynetwork web
      docker network connect mynetwork db 
;    - Questo forza i container a collegarsi al network
;    - Dopo, ripeti docker network inspect mynetwork per confermare